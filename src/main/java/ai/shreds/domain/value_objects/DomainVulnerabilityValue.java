package ai.shreds.domain.value_objects;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.Value;

/**
 * Value object representing a security vulnerability.
 * Contains detailed information about a vulnerability found during scanning.
 */
@Value
@Builder
@Getter(AccessLevel.PUBLIC)
public class DomainVulnerabilityValue {

    /**
     * Type or category of the vulnerability.
     */
    String type;

    /**
     * Severity level of the vulnerability.
     */
    DomainVulnerabilitySeverity severity;

    /**
     * Detailed description of the vulnerability.
     */
    String description;

    /**
     * Location where the vulnerability was found.
     */
    String location;

    /**
     * Creates a new vulnerability with the specified parameters.
     *
     * @param type Vulnerability type
     * @param severity Severity level
     * @param description Detailed description
     * @param location Where the vulnerability was found
     */
    public DomainVulnerabilityValue(String type, DomainVulnerabilitySeverity severity,
                                   String description, String location) {
        this.type = type;
        this.severity = severity;
        this.description = description;
        this.location = location;
        validate();
    }

    /**
     * Validates the vulnerability details.
     *
     * @throws IllegalArgumentException if validation fails
     */
    public void validate() {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability type cannot be null or empty");
        }
        if (severity == null) {
            throw new IllegalArgumentException("Severity cannot be null");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Description cannot be null or empty");
        }
        if (location == null || location.trim().isEmpty()) {
            throw new IllegalArgumentException("Location cannot be null or empty");
        }
    }

    /**
     * Checks if this vulnerability is considered high risk.
     *
     * @return true if severity is HIGH or CRITICAL
     */
    public boolean isHighRisk() {
        return severity.isHighRisk();
    }

    /**
     * Creates a copy of this vulnerability with a new severity level.
     *
     * @param newSeverity The new severity level
     * @return A new vulnerability instance
     */
    public DomainVulnerabilityValue withNewSeverity(DomainVulnerabilitySeverity newSeverity) {
        return new DomainVulnerabilityValue(type, newSeverity, description, location);
    }

    /**
     * Creates a copy of this vulnerability with an updated description.
     *
     * @param additionalInfo Additional information to append
     * @return A new vulnerability instance
     */
    public DomainVulnerabilityValue withAdditionalInfo(String additionalInfo) {
        if (additionalInfo == null || additionalInfo.trim().isEmpty()) {
            return this;
        }
        return new DomainVulnerabilityValue(
            type,
            severity,
            description + " " + additionalInfo,
            location
        );
    }

    /**
     * Gets a formatted string representation of the vulnerability.
     *
     * @return Formatted vulnerability details
     */
    public String getFormattedDetails() {
        // Single-line format to avoid any possible hidden newline issues
        return String.format("[%s] %s - Severity: %s Location: %s Description: %s", 
            type, 
            severity.getValue(), 
            severity.getDescription(), 
            location, 
            description
        );
    }
}
